
<p>There has been some interest in the community around how to use the osullivan gem to generate manifests, so I have decided to write a blog post that will document my experience and hopefully be of some use to others who want to start using osullivan.  In this post, I will step through the process of cooking up a utility app that will turn structured data in the METS format into IIIF Presentation API manifests.  </p>

<p>Since we are “cleaning up” the extensive METS data to make it “presentable” on the web, I’m calling the app “spiiiffy”.  Our infrastructure already has lots of support for Rails apps, so I’m going to go with the flow and use ruby 2.0.0p451 paired with Rails 4.2.0.  Here we go:</p>

<p><code>
rails new spiiiffy
</code></p>

<p>Spiiiffy will need to take a URL that provides a METS document, use the nokogiri to parse the XML data, and use the osullivan gem to create the Presentation API manifest structure.  Then it will need to store both datastreams and deliver either depending on the request.</p>

<p>So we modify our Gemfile by adding these lines:</p>

<p>```
…</p>

<h1 id="use-nokogiri-for-xml-parsing">Use Nokogiri for XML parsing</h1>
<p>gem ‘nokogiri’, ‘&gt;= 1.6.6.2’</p>

<h1 id="use-osullivan-for-manifest-creation">Use osullivan for Manifest creation</h1>
<p>gem ‘osullivan’, ‘&gt;= 0.0.3’</p>

<p>…
``` </p>

<p>Let’s generate our Metadata model and run the migration to create the table:</p>

<p><code>
rails generate scaffold Metadata mets:longtext manifest:longtext title:string
bundle exec rake db:migrate
</code></p>

<p>Add the accessors to the model:</p>

<p>```
class Metadatum &lt; ActiveRecord::Base
  attr_accessor :mets, :manifest, :title, :objid
  …</p>

<p>…
end
```</p>

<p>Before saving, extract the title and objid from the record for human and computer usability:</p>

<p>```
…
  before_create :set_title, :set_objid
  before_update :set_title, :set_objid</p>

<p>private
    def set_title
      mets_doc  = Nokogiri::XML(self.mets)
      self.title = mets_doc.xpath(‘(//mods:titleInfo/mods:title/text())[1]’, ‘mods’ =&gt; ‘http://www.loc.gov/mods/v3’)
      self.title.blank? ? “untitled” : self.title
    end</p>

<p>private
    def set_objid
      mets_doc  = Nokogiri::XML(self.mets)
      self.objid = mets_doc.xpath(‘string(//mets:mets/@OBJID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
    end</p>

<p>…</p>

<p>```</p>

<p>We’re going to make sure that we can get to the object using the OBJID instead of the Rails internal id.</p>

<p>```
…</p>

<p>def to_param
    objid
  end</p>

<p>#validates_format_of :objid, :with =&gt; /\A[a-z].+\z/
  def self.find(input)
    input.to_i == 0 ? find_by_objid(input) : super
  end</p>

<p>…
```</p>

<p>Start building a manifest with osullivan</p>

<p><code>
...
  private
    def make_manifest
      seed = {
        '@id' =&gt; 'http://localhost:3000/metadata/#{self.objid}',
        'label' =&gt; self.title
      }
      # Any options you add are added to the object
      self.manifest = IIIF::Presentation::Manifest.new(seed)
    end
...
</code>
 Note: for some reason, I needed to add <code>require 'iiif/presentation'</code> to the top of the model file even though it’s in the Gemfile.  May not be loading correctly.</p>

<p>I should probably write a test for this, but just to quickly check to make sure it’s working, I spun up the rails server and noticed the json data in the manifest textarea when attempting to edit a record.  Huzzzaaah, a baby manifest!</p>

<p>Now we’re starting to really get our hands dirty, and it’s probably time to refactor some things. For example, in both set_title and set_objid we are doing the same thing:</p>

<p><code>mets_doc  = Nokogiri::XML(self.mets)</code></p>

<p>We should pull these duplicate steps out and when initialized we create a Nokogiri nodeset object that’s accessible to all methods within this class.  I don’t know how to do this yet.</p>

<p>We will put off the refactoring for the moment in the interest of working code. The next step is to iterate over the mets:structMap and add canvases to our baby manifest. So, yet again, we create a Nokogiri doc from the METS, get our ordered list, and also grab all the image files from the fileSec:</p>

<p>```
mets_doc  = Nokogiri::XML(self.mets)</p>

<h1 id="get-structmap--start-with-ordered-list">get structMap … start with ordered list</h1>
<p>ol = mets_doc.xpath(‘//mets:structMap/mets:div/mets:div[@TYPE=”OrderedList”]/mets:div’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)</p>

<h1 id="get-filesec">get fileSec</h1>
<p>files = mets_doc.xpath(‘//mets:fileSec/mets:fileGrp[@USE=”deliverables”]/mets:file’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’, ‘xlink’ =&gt; ‘http://www.w3.org/1999/xlink’)
```</p>

<p>Our mets:file references have two different identifiers in addition to a URN associated with them.  One identifier (@ADMID) is used by mets:techMD and the other (@ID) is usec by mets:structMap.  In order to easily work access both, I’m going to create a hash with both of these identifiers and grab our :</p>

<p>```
files_hash = Hash.new</p>

<p>files.each do |file|
  fid = file.xpath(‘string(@ID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’, ‘xlink’ =&gt; ‘http://www.w3.org/1999/xlink’)
  fadmid = file.xpath(‘string(@ADMID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’, ‘xlink’ =&gt; ‘http://www.w3.org/1999/xlink’)
  files_hash[fid] = fadmid
end<br />
```
Ok, so it’s easy to get the label and order number from our structMap, and we can use that file_hash to get at the image dimensions to set on each canvas: </p>

<p>```
ol.each do |item|
        label = item.xpath(‘string(@LABEL)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        order = item.xpath(‘string(@ORDER)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        item_id = item.xpath(‘string(mets:fptr/@FILEID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)</p>

<pre><code>    item_aid = files_hash[item_id]

    iw = '//techMD[@ID="' + item_aid + '"]//imageWidth/text()'
    ih = '//techMD[@ID="' + item_aid + '"]//imageHeight/text()'

    img_width = mets_doc.xpath(iw, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s
    img_height = mets_doc.xpath(ih, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s
	# let's print out the img_width to make sure this is working...
	puts img_width end ``` Uh oh!  Nothing!  Looking at the mets:techMD section I think there's a namespace issue in getting at our image dimensions:
</code></pre>

<p><code>
&lt;mets:techMD ID="uoma"&gt;
  &lt;mets:mdWrap MDTYPE="NISOIMG"&gt;
    &lt;mets:xmlData&gt;
      &lt;mix xmlns="http://www.loc.gov/mix/v20" xsi:schemaLocation="http://www.loc.gov/mix/v20 http://www.loc.gov/standards/mix/mix20/mix20.xsd"&gt;
        &lt;BasicImageInformation&gt;
          &lt;BasicImageCharacteristics&gt;
            &lt;imageWidth&gt;5674&lt;/imageWidth&gt;
            &lt;imageHeight&gt;7200&lt;/imageHeight&gt;
          &lt;/BasicImageCharacteristics&gt;
        &lt;/BasicImageInformation&gt;
      &lt;/mix&gt;
    &lt;/mets:xmlData&gt;
  &lt;/mets:mdWrap&gt;
&lt;/mets:techMD&gt;
</code></p>

<p>Yes, there’s probably a better way to do this, but I don’t mind being a bit sloppy here in the interest of getting working code.  I’m going to clone the mets_doc and wipe out the namespaces for this one step:</p>

<p>```
slop = mets_doc.clone
slop.remove_namespaces!</p>

<p>ol.each do |item|
        label = item.xpath(‘string(@LABEL)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        order = item.xpath(‘string(@ORDER)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        item_id = item.xpath(‘string(mets:fptr/@FILEID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)</p>

<pre><code>    item_aid = files_hash[item_id]

    iw = '//techMD[@ID="' + item_aid + '"]//imageWidth/text()'
    ih = '//techMD[@ID="' + item_aid + '"]//imageHeight/text()'

    img_width = slop.xpath(iw, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s
    img_height = slop.xpath(ih, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s
	# let's print out the img_width to make sure this is working...
	puts img_width end ```
</code></pre>

<p>Hooray! Now we can remove our puts statement and actually add all this data to the Canvas.  The full block would look like this:
```
      ol.each do |item|
        label = item.xpath(‘string(@LABEL)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        order = item.xpath(‘string(@ORDER)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)
        item_id = item.xpath(‘string(mets:fptr/@FILEID)’, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’)</p>

<pre><code>    item_aid = files_hash[item_id]

    iw = '//techMD[@ID="' + item_aid + '"]//imageWidth/text()'
    ih = '//techMD[@ID="' + item_aid + '"]//imageHeight/text()'

    img_width = slop.xpath(iw, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s
    img_height = slop.xpath(ih, 'mets' =&gt; 'http://www.loc.gov/METS/').to_s

    canvas = IIIF::Presentation::Canvas.new()

    canvas['@id'] = "#{m['@id']}/canvas/#{order}"

    canvas.width = img_width.to_i
    canvas.height = img_height.to_i
    canvas.label = label

    # put the code for grabbing images here

    m.sequences &lt;&lt; canvas
    self.manifest = m.to_json(pretty:false)
  end ```
</code></pre>

<p>So, that is a long block.  In fact, we’re going to need to make it longer because in the same pass we are going to want to add the Images to the Canvas before adding it to <code>m.sequences</code>:</p>

<p>```
i_urn = ‘//mets:file[@ADMID=”’ + item_aid +’”]/mets:FLocat/@xlink:href’
img_id = mets_doc.xpath(i_urn, ‘mets’ =&gt; ‘http://www.loc.gov/METS/’, ‘xlink’ =&gt; ‘http://www.w3.org/1999/xlink’).to_s.sub(/^urn:pudl:images:deliverable:/,’’)</p>

<p>i = IIIF::Presentation::ImageResource.new()</p>

<p>i[‘@id’] = “http://libimages.princeton.edu/loris2/#{img_id}/full/#{img_width},#{img_height}/0/default.jpg”
i.format = “image/jpeg”
i.width = canvas.width
i.height = canvas.height</p>

<p>r = IIIF::Presentation::Resource.new(‘@type’ =&gt; ‘oa:Annotation’, ‘motivation’ =&gt; ‘sc:painting’, ‘@id’ =&gt; ‘#{canvas[“@id”]}/images’, ‘resource’ =&gt; i)</p>

<p>canvas.images « r</p>

<p>```</p>

<p>Ok, we have to do one more thing before we can have a workable IIIF Manifest: add the service information.  This should be rather simple as we just need to create a new resource that we stuff into the ImageResource, the same way we inserted the ImageResource into the Images Resource that lists ImageResources (I know, it gets crazy!).  Probably simpler to show:</p>

<p>```
s = IIIF::Presentation::Resource.new(‘@context’ =&gt; ‘http://iiif.io/api/image/2/context.json’, ‘profile’ =&gt; ‘http://iiif.io/api/image/2/level2.json’, ‘@id’ =&gt; “http://libimages.princeton.edu/loris2/#{img_id}”)</p>

<pre><code>    i = IIIF::Presentation::ImageResource.new()

    i['@id'] = "http://libimages.princeton.edu/loris2/#{img_id}/full/#{img_width},#{img_height}/0/default.jpg"
    i.format = "image/jpeg"
    i.width = canvas.width
    i.height = canvas.height
    i.service = s ```
</code></pre>

<p>So, what is this @context and profile stuff?  See this:
https://wiki1.hbz-nrw.de/display/SEM/2013/08/01/Sharing+context+-+publishing+application+profiles+with+JSON-LD</p>

